## Таблицы в базе данных:
- Для хранения uuid товара достаточно использовать поле типа CHAR(36). Если мы используем postgresSql, то там есть специальный тип UUID.
- Добавил поле "Название товара" (product_name).
- Ключевое слово "name" зарезервировано. Лучше не использовать его в качестве имени столбца.
- Нет необходимости указывать "NULL" у столбцов, т.к. они по умолчанию и так могут иметь значение null. 
- Привык для названия таблиц использовать существительные в единственном числе (product, category).
- Хранение названий категорий товаров в таблице товаров ведёт к избыточности и несогласованности данных. Категория товара это отдельная абстракция, записи которой должны храниться в таблице "Категории товаров" (category).
- Добавил поле "Категория товара" (category_id), которое является внешним ключом на таблицу "category".
- Для таблицы с товарами добавил индекс на внешний ключ (поле "Категория товара" (category_id)), для ускорения операций поиска и соединения таблиц по этому внешнему ключу.
- Удлинил названия индексов, чтобы было понятно, к какой таблице они относятся.

## Замечания по коду:
- В проекте используются папки Domain, Infrastructure. Это намекает нам на то, что используются элементы слоистой архитектуры. Тогда все контроллеры, реализации сервисов, фабрик, валидаторов и т.д. должны находиться в инфраструктурном слое (в папке Infrastructure). Доменный слой же должен состоять из доменных сущностей, репозиториев, фабрик, агрегатов и value objects.
- В проекте нет никаких интерфейсов, необходимо их добавить.
  
### Сущности (Entity):
- Было странное расположение сущностей в папке Repository\Entity. Исправил это, все сущности разместил в папке Domain\Entity.
- У сущности "Товар" (Product) нет интерфейса. Добавил его.
- В интерфейсе товара указал нужные геттеры и сеттеры (хоть сеттеры здесь и не обязательны, по заданию товар не нужно сохранять).
- Поля id и uuid должны быть неизменяемыми (сделал их ещё и readonly), т.к. это уникальные значения товара, устанавливаемые при его создании.
- По аналогии сделал сущности "Покупатель" (Customer) и "Категория товара" (Category).

### Агрегаты (Aggregate):
  Классы Cart и CartItem правильно расположены в папке Domain, т.к. это наши доменные абстракции. Cart - это типичный агрегат. CartItem - его составная часть. По заданию нам требуется только добавление в него элементов.
- Создал интерфейс CartInterface.
- Метод addItem теперь возвращает экземпляр.
- Свойство customer сделал типа CustomerInterface.

### Репозитории (Repository):
- Интерфейсы репозиториев описал в доменном слое, а реализации - в инфраструктурном. 
- Теперь для запросов указываю placeholders.
- В методе getByUuid использую fetchAssociative.
- В методе getByCategory поменял статическую анонимную функцию на обычную. В статической не получилось бы обратиться к $this.

### RowValidator'ы
Результат sql запроса как-то надо преобразовать в нашу сущность. Это можно было бы легко сделать, будь у нас orm. Но здесь у нас только dbal, поэтому сам напишу логику преобразования.
- В репозиторий внедрил экземпляры ProductRowValidatorInterface и ProductFactoryInterface. Первый предназначен для валидации результата запроса, второй это фабрика, куда передаётся провалидированный результата запроса (ProductRowResult)
- Сделал тоже самое и для репозитория категорий (CategoryRepository)

### CartRepository:
Здесь вообще всё свалено в кучу. CartManager это типичный репозиторий. Он не должен наследовать ConnectorFacade, это разные абстракции.
- Переименовал CartManager в CartRepository.
- Добавил интерфейсы ConnectorInterface и ConnectorFacadeInterface. Потому что мы не должны рассчитывать только на одну реализацию коннектора.
- Создал RedisConnector и RedisConnectorFacade интерфейс как реализации ConnectorInterface и ConnectorFacadeInterface соответственно. 
- CartRepository инкапсулирует в себя экземпляр ConnectorFacadeInterface. Т.о, каждая конкретная реализация репозитория (CartRepositoryInterface) не зависит от конкретного ConnectorFacade, да и от ConnectorFacadeInterface вцелом. 

Каждая корзина (CartInterface) должна содержать в себе покупателя (поле customer), каждый элемент корзины (CartItem) должен содержать в себе uuid продукта (поле productUuid). Мы не можем просто сериализовать customer и productUuid как объекты, потому что при десериализации в получившемся экземпляре корзины (CartInterface) у нас сразу будут готовые Product и CartItem объекты, состояния которых могут отличаться от актуальных значений в хранилищах. Это несогласованность данных.
- В CartRepository описал логику (метод fromArray), которая загружает все товары и покупателей, которые необходимы нашему экземпляру корзины (CartInterface)

### CartView и ProductsView
- В них не должно быть репозиториев. Убрал из них репозитории.
- Все нужные данные содержаться в экземплярах CartInterface и ProductInterface.

### Контроллеры
В контроллерах описал следующую последователбность действий:
- Создание DTO
- Валидация DTO
- Выполнение соответствущего метода сервиса
- Возврат сообщения об успехе.
- Или обработка исключения из сервиса, логирование ошибки, возврат сообщения об ошибке.

Считаю, что делать контроллер тоньше нет смысла, он и так компактный.

### Итог
Вероятно, я не заметил многие ошибки. Не протестировал написанное. Но задание вышло объёмным. В нём я постарался охватить самое главное - написать чистый и расширяемый код, пытаясь придерживаться некоторых правил луковой архитектуры.
